# Creating queries for HTTP requests

`qs` is the underlying system for parsing json files in Strapi, and can be used on the client side to generate queries to the server ([link](https://github.com/ljharb/qs)).

The documentation for how `qs` works in Strapi is not clear, though it is comprehensive (the examples can be a little baffling). In attempt to add some clarity, here are some examples of code and responses, and how it works with JS.

The Strapi docs are [here](https://docs.strapi.io/dev-docs/api/rest/populate-select).

# Example JSON

Using this command (at the time for this writing): `http://localhost:1337/api/user-dictionaries?populate=*` will generate this (abridge) content:

```json
{
  "data": [
    {
      "id": 7,
      "attributes": {
        "createdAt": "2023-12-06T13:18:26.148Z",
        "updatedAt": "2023-12-06T13:48:42.540Z",
        "user": {
          "data": {
            "id": 2,
            "attributes": {
              "username": "test2@test.com",
              "email": "test2@test.com",
              "provider": "local",
              "confirmed": true,
              "blocked": false,
              "createdAt": "2023-11-26T18:38:01.614Z",
              "updatedAt": "2023-11-26T18:38:01.614Z"
            }
          }
        },
        "user_words": [
          {
            "id": 3,
            "status": "visible"
          },
          {
            "id": 4,
            "status": "hidden"
          }
        ]
      }
    },
    {
      "id": 8,
      "attributes": {
        "createdAt": "2023-12-06T13:49:04.883Z",
        "updatedAt": "2023-12-06T13:49:04.883Z",
        "user": {
          "data": {
            "id": 1,
            "attributes": {
              "username": "test@test.com",
              "email": "test@test.com",
              "provider": "local",
              "confirmed": true,
              "blocked": false,
              "createdAt": "2023-11-11T19:31:54.393Z",
              "updatedAt": "2023-11-11T19:31:54.393Z"
            }
          }
        },
        "user_words": [
          {
            "id": 5,
            "status": "visible"
          }
        ]
      }
    }
  ],
  "meta": {
    "pagination": {
      "page": 1,
      "pageSize": 25,
      "pageCount": 1,
      "total": 2
    }
  }
}
```

The `?populate=*` query is a shortcut for showing everything; without it, you'll only get the topmost, very sparse, part of the JSON, with nothing nested.

# A Semi-Complicated Query

The goal of this example is to pull and show only certain fields (the user.username of a specific user and the user_words). This is the GET query:

`http://localhost:1337/api/user-dictionaries?filters[$and][0][user][username][$eq]=test2@test.com&filters[$and][1][user_words][status][$eq]=hidden&populate[user][fields][0]=username&populate[user_words][fields][0]=status`

What this responds with is this:

```json
{
  "data": [
    {
      "id": 7,
      "attributes": {
        "createdAt": "2023-12-06T13:18:26.148Z",
        "updatedAt": "2023-12-06T13:48:42.540Z",
        "user": {
          "data": {
            "id": 2,
            "attributes": {
              "username": "test2@test.com"
            }
          }
        },
        "user_words": [
          {
            "id": 3,
            "status": "visible"
          },
          {
            "id": 4,
            "status": "hidden"
          }
        ]
      }
    }
  ],
  "meta": {
    "pagination": {
      "page": 1,
      "pageSize": 25,
      "pageCount": 1,
      "total": 1
    }
  }
}
```

The `qs` syntax can be a little hard to read and is sometimes permissive and other times very restrictive; this means your query might be different from this one and still work, within reason. This particular query was generated by Strapi's interactive tool, [here](https://docs.strapi.io/dev-docs/api/rest/interactive-query-builder), which I'll touch on later.

How the query works is for this example is as follows:

The `filters` query has two parts, both required, so there is an `[$and]` participle to facilitate that logic. You think of the two parts (one part for the username and the other for status) as two elements in an arbitrary, anonymous, array. This is why there are the two numbered indices, `[0]` and `[1]` on the two `filters` (which are in turn separated by the `&` query connector).

The result of the filters part is to focus the data; however, you still need to populate it in order to see it in the HTTP response. This is where the `populate` syntax comes in.

As you can see in the original JSON, each element has two sub-elements that I'm interested in seeing, the `user` and the `user_words`, so I need two `populate` commands (separated by the `&` again). Let's focus on one element only: `populate[user][fields][0]=username`

What is essentially happening here is that I'm asking Strapi to populate the `user` element with the `[fields]` that are called `username`. The `[0]` is a placeholder in this particular case; if I needed to filter on more fields under the `[user]` element, I'd add more, incrementing the indices each time (so the next would be `[1]`). In this case, you can remove the `[0]` and still get the same results (demonstrating the permissiveness of `qs` in the particular case).

## Interactive Query Tool

The [Interactive Query Tool](https://docs.strapi.io/dev-docs/api/rest/interactive-query-builder) is barely what I would call interactive, but it does have its uses for following stricter standards while using `qs`.

To generate the main (long) URL, I used the following code in the tool:

```javascript
{
  filters:
  {
    $and:
    [
      {
        user: {
          username: {
            $eq: 'test2@test.com'
          }
        },
      },
      {
        user_words: {
          status: {
            $eq: 'hidden'
          }
        }
      }
    ]
  },
  populate:
  {
    user: {
      fields: ['username', 'email']
    },
        user_words: {
      fields: ['status']
    }
  }
}
```

This helps a little in seeing how the URL query portion gets created. You can see the `$and` key and how it takes an array with (in this case) two elements, thus showing the `[0]` and `[1]` in the URL. If I were to replace the `user` field with this: `fields: ['username', 'email']`, then that portion of the URL would change to be this: `populate[user][fields][0]=username&populate[user][fields][1]=email`; the HTTP response in turn would add the `email` field to the output, demonstrating how the indices work in the query.

The point of the interactive tool is that you can then us it with the `qs` library in the code to more easily generate the query than trying to handwrite it out each time (for fewer brackets and all that).

# Conclusion

This is far from being a complete instruction on how to use `qs` in the context of Strapi. The 
